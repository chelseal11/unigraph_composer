<!DOCTYPE html>
<html>
  <head>
    <title>Unigraph Composing</title>
    <style>
      .hidden {
        display: none;
      }
      .static_height {
        min-height: 150px;
      }
      .dropdown-container {
        display: block;
      }
      .graph-section {
        margin-bottom: 15px;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #ffffff;
        width: 470px;
      }
      .graph-section h3 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #333;
        font-size: 1.1em;
      }
    </style>
  </head>
  <body>
    <div id="start-screen">
      <button onclick="showComposeUnigraphs()">Compose Unigraphs</button>
      <button onclick="showRandomUnigraphGenerator()">Random Unigraph Generator</button>
      <button onclick="showDecompose()">Graph Decomposition and Unigraph Detection Tool</button>
      <button onclick="showComposeGraphs()">Compose Graphs</button>
    </div>

    <div id="compose-unigraphs" class="hidden">
      <h2>Unigraph Composition Tool</h2>
      <p>Configure two graphs below and compute their composition:</p>

      <div class="dropdown-container">
        <!-- Dynamic HTML will be generated here -->
      </div>

      <button style="width: 500px; height: 50px; font-size: 1.2em;" onclick="computeComposition()">Compute Composition</button>

      <div id="result-container" style="margin-top: 20px;">
        <div id="composition-result-short" style="width: 470px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Compute Composition' to see the result here..."></div>
        <!-- <div id="composition-result-long" style="width: 470px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Compute Composition' to see the result here..."></div> -->
      </div>
    </div>

    <div id="random-unigraph-generator" class="hidden">
      <h2>Random Unigraph Generator</h2>
      <label for="num-vertices">Number of vertices (1-20):</label>
      <input type="number" id="num-vertices" name="num-vertices" min="1" max="20" value="1">
      <br>
      <br>
      <label for="num-graphs">Number of basic components (1-3):</label>
      <input type="number" id="num-graphs" name="num-graphs" min="1" max="3" value="1">
      <br>
      <br>
      <button style="width: 250px; height: 30px; font-size: 1em;" onclick="computeRandomUnigraph()">Compute Random Unigraph</button>
      <br>
      <br>
      <div id="random-unigraph-1" style="width: 470px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Compute Random Unigraph' to see the result here..."></div>
      <br>
      <div id="random-unigraph-2" style="width: 470px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Compute Random Unigraph' to see the result here..."></div>
      <br>
      <div id="random-unigraph-3" style="width: 470px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Compute Random Unigraph' to see the result here..."></div>
      <br>
      <div id="final-result-short" style="width: 470px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Compute Random Unigraph' to see the result here..."></div>
      <br>
      <!-- <div id="final-result-long" style="width: 470px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Compute Random Unigraph' to see the result here..."></div> -->
    </div>

    <div id="decompose-graph" class="hidden">
      <h2>Graph Decomposition and Unigraph Detection Tool</h2>
      <p>Decompose a graph into its basic components:</p>
      <input type="text" id="decompose-graph-input" style="width: 550px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" placeholder="Enter a graph to decompose... Example: 5^2, 4^3, 1^1">
      <br>
      <br>
      <button style="width: 250px; height: 30px; font-size: 1em;" onclick="decomposeGraph()">Decompose Graph</button>
      <br>
      <br>
      <div id="decompose-graph-result" style="width: 550px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Decompose Graph' to see the result here..."></div>
      <br>
    </div>

    <div id="compose-graphs" class="hidden">
      <h2>Graph Composition Tool</h2>
      <p>Compose a graph by degree sequence:</p>
      <input type="text" id="compose-graphs-input-1" style="width: 550px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" placeholder="Enter a graph to compose... Example: 5^2, 4^3, 1^1">
      <br>
      <br>
      <input type="text" id="compose-graphs-input-2" style="width: 550px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" placeholder="Enter a split graph to compose... Example: 2^1 ; 1^1">
      <br>
      <br>
      <button style="width: 250px; height: 30px; font-size: 1em;" onclick="graphComposition()">Compose Graphs</button>
      <br>
      <br>
      <div id="compose-graphs-result" style="width: 550px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 15px; border-radius: 4px; color: #666;" data-placeholder="Click 'Compose Graphs' to see the result here..."></div>
      <br>
    </div>

    <script>
      // Global variable to store the previous composition result
      let previousResult = null;

      // Configuration object for graph types and their required inputs
      const GRAPH_CONFIG = {
        'C5': {
          inputs: [],
          validation: [],
          degSequence: () => ({2: 5}),
          potentialVertices: [5],
          potentialParamsByNumVertices: (numVertices) => ([{}]),
          distinguishingNumber: () => 3
        },
        'mK2': {
          inputs: ['m'],
          validation: [{ param: 'm', min: 2, name: 'mKâ‚‚' }],
          degSequence: ({m}) => ({1: 2 * m}),
          potentialVertices: [4,6,8,10,12,14,16,18,20],
          potentialParamsByNumVertices: (numVertices) => (
            [{m: numVertices / 2}]
          ),
          distinguishingNumber: (m) => {
            return (Math.ceil((1 + Math.sqrt(1 + 8*m)) / 2))
          }
        },
        'U2': {
          inputs: ['m', 'l'],
          validation: [
            { param: 'm', min: 1, name: 'U2(m, l)' },
            { param: 'l', min: 2, name: 'U2(m, l)', displayName: 'l' }
          ],
          degSequence: ({m, l}) => ({
            [l]: 1,
            1: (2 * m) + l
          }),
          potentialVertices: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],
          potentialParamsByNumVertices: (numVertices) => {
            const result = [];

            for (let m = 1; m <= 8; m++) {
              const l = numVertices - (2 * m) - 1;
              if (l >= 2) {
                result.push({ m, l });
              }
            }

            return result;
          },
          distinguishingNumber: (m, l) => {
            return Math.ceil(GRAPH_CONFIG['mK2'].distinguishingNumber(m), l)
          }
        },
        'U3': {
          inputs: ['m'],
          validation: [{ param: 'm', min: 1, name: 'U3(m)' }],
          degSequence: ({m}) => ({
            [(2 * m) + 2]: 1,
            2: (2 * m) + 3
          }),
          potentialVertices: [6,8,10,12,14,16,18,20],
          potentialParamsByNumVertices: (numVertices) => {
            return [{m: (numVertices - 4) / 2}];
          },
          distinguishingNumber: (m) => (GRAPH_CONFIG['mK2'].distinguishingNumber(m))
        },
        'SVG': {
          split: true,
          inputs: ['partition'],
          validation: [],
          degSequence: ({partition}) => {
            if (partition === 'A') {
              return {
                A: {0: 1},
                B: {}
              };
            } else {
              return {
                A: {},
                B: {0: 1}
              };
            }
          },
          potentialVertices: [1],
          potentialParamsByNumVertices: (numVertices) => ([{}]),
          distinguishingNumber: (degreeSequence) => {
            if (degreeSequence.A === undefined || degreeSequence.B === undefined) {
              return undefined;
            }
            const aTotalVertices = Object.values(degreeSequence.A).reduce((acc, curr) => acc + curr, 0);
            const bTotalVertices = Object.values(degreeSequence.B).reduce((acc, curr) => acc + curr, 0);
            return aTotalVertices + bTotalVertices;
          }
        },
        'Spq': {
          split: true,
          inputs: ['p', 'q'],
          validation: [
            { param: 'p', min: 1, name: 'S(p, q)' },
            { param: 'q', min: 2, name: 'S(p, q)' }
          ],
          degSequence: ({p, q}) => ({
            A: {[p + q - 1]: q},
            B: {1: p * q}
          }),
          potentialVertices: [4,6,8,9,10,12,14,15,16,18,20],
          potentialParamsByNumVertices: (numVertices) => {
            const result = [];

            for (let p = 1; p <= 9; p++) {
              if (numVertices % (p + 1) === 0) {
                const q = numVertices / (p + 1);
                if (q >= 2) {
                  result.push({ p, q });
                }
              }
            }
            return result;
          },
          distinguishingNumber: (p, q) =>{
            if (p === undefined || q === undefined) return undefined;
            for (let c = 1; c <= 100; c++) {
              const c_factorial = factorial(c);
              const p_factorial = factorial(p);
              const c_minus_p_factorial = factorial(c - p);
              const denominator = p_factorial * c_minus_p_factorial;
              if (denominator === 0) return;
              const result = Math.round(c_factorial / denominator);
              if (result >= q ) return result;
            }
          }
        },
        'S2': {
          split: true,
          inputs: ['m'],
          validation: [{ param: 'm', min: 2, name: 'S2' }],
          dynamic: true,
          degSequence: (params) => {
            // n is the sum of qi from i=1 to m, calculated in getDegreeSequence
            const m = params.m;
            let n = 0;
            const A = {};
            const B = {};

            for (let i = 1; i <= m; i++) {
              n += params[`q${i}`];
            }

            for (let i = 1; i <= m; i++) {
              const pi = params[`p${i}`];
              const qi = params[`q${i}`];
              A[pi + n - 1] = qi;
              if (B[1] === undefined) {
                B[1] = 0;
              }
              B[1] += pi * qi;
            }

            return {
              A: A,
              B: B
            };
          },
          potentialVertices: [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],
          potentialParamsByNumVertices: (numVertices) => (enumerateParamsForTotal(numVertices)),
          distinguishingNumber: (params) => {
            const m = params.m;
            const p = params.p;
            const q = params.q;
            let max = 0;
            for (let i = 1; i <= m; i++) {
              const p_q = GRAPH_CONFIG['Spq'].distinguishingNumber(p[i], q[i]);
              max = Math.max(max, p_q);
            }
            return max;
          }
        },
        'S3': {
          split: true,
          inputs: ['p', 'q1', 'q2'],
          validation: [
            { param: 'p', min: 1, name: 'S3(p, q1, q2)' },
            { param: 'q1', min: 2, name: 'S3(p, q1, q2)' },
            { param: 'q2', min: 1, name: 'S3(p, q1, q2)' }
          ],
          degSequence: ({p, q1, q2}) => ({
            A: {[p + q1 + q2]: q1 + q2},
            B: {
              [q1]: 1,
              1: (p * q1) + ((p + 1) * q2)
            }
          }),
          potentialVertices: [8,10,11,12,13,14,15,16,17,18,19,20],
          potentialParamsByNumVertices: (numVertices) => {
            const result = [];
            for (let p = 1; p <= 5; p++) {
              for (let q1 = 2; q1 <= 8; q1++) {
                const numerator = numVertices - q1 - (p * q1) - 1;
                const denominator = p + 2;
                if (numerator % denominator === 0) {
                  const q2 = numerator / denominator;
                  if (q2 >= 1) {
                    result.push({ p: p, q1: q1, q2: q2 });
                  }
                }
              }
            }
            return result;
          },
          distinguishingNumber: (p, q1, q2) => {
            const p_q1 = GRAPH_CONFIG['Spq'].distinguishingNumber(p, q1);
            const p_plus_1_q2 = GRAPH_CONFIG['Spq'].distinguishingNumber(p + 1, q2);
            return Math.max(p_q1, p_plus_1_q2)
          }
        },
        'S4': {
          split: true,
          inputs: ['p', 'q'],
          validation: [
            { param: 'p', min: 1, name: 'S4(p, q)' },
            { param: 'q', min: 1, name: 'S4(p, q)' }
          ],
          degSequence: ({p, q}) => ({
            A: {
              [2 * (p + q + 1) + q]: 1,
              [p + q + 3]: q + 2
            },
            B: {2: (q * p) + (2 * p) + q + 1}
          }),
          potentialVertices: [9,12,15,16,18,20],
          potentialParamsByNumVertices: (numVertices) => {
            const results = [];
            for (let p = 1; p <= 4; p++) {
              const denominator = p + 2;
              if (numVertices % denominator === 0) {
                const q = (numVertices / denominator) - 2;
                if (q >= 1) {
                  results.push({ p: p, q: q });
                }
              }
            }
            return results;
          },
          distinguishingNumber: (p, q) => {
            const p_2 = GRAPH_CONFIG['Spq'].distinguishingNumber(p, 2);
            const p_plus_1_q = GRAPH_CONFIG['Spq'].distinguishingNumber(p + 1, q);
            return Math.max(p_2, p_plus_1_q)
          }
        },
        'PreviousResult': {
          inputs: [],
          validation: [],
          degSequence: () => previousResult
        }
      };

      const calculateComplement = (g) => {
        const sizeOfG = calculateSizeOfGraph(g);
        if (g.A !== undefined) {
          return {
            A: complementSequence(g.B, calculateSizeOfGraph(g)),
            B: complementSequence(g.A, calculateSizeOfGraph(g))
          };
        } else {
          return complementSequence(g, calculateSizeOfGraph(g));
        }
      };

      const complementSequence = (sequence, sizeOfG) => {
        const complement = {};
        Object.entries(sequence).forEach(([k, v]) => {
          const newDegree = sizeOfG - k - 1;
          complement[newDegree] = v;
        });
        return complement;
      };

      const calculateInverse = (g) => {
        if (g.A !== undefined) {
          return {
            A: invertB(g.B),
            B: invertA(g.A)
          };
        } else {
          alert(`Graph is not split and can't be inverted`);
          return null;
        }
      };

      const invertA = (a) => {
        const inverse = {};
        const sizeOfA = calculateSizeOfGraph(a) - 1;
        Object.entries(a).forEach(([k, v]) => {
          const newDegree = Number(k) - sizeOfA;
          inverse[newDegree] = v;
        });
        return inverse;
      };

      const invertB = (b) => {
        const inverse = {};
        const sizeOfB = calculateSizeOfGraph(b) - 1;
        Object.entries(b).forEach(([k, v]) => {
          const newDegree = Number(k) + sizeOfB;
          inverse[newDegree] = v;
        });
        return inverse;
      };

      // Define which graph types are available for each dropdown
      const GRAPH_OPTIONS = {
        1: ['C5', 'mK2', 'U2', 'U3', 'SVG', 'Spq', 'S2', 'S3', 'S4', 'PreviousResult'],
        2: ['SVG', 'Spq', 'S2', 'S3', 'S4']
      };

      const GRAPH_LABELS = {
        'C5': 'Câ‚…',
        'mK2': 'mKâ‚‚ for m â‰¥ 2',
        'U2': 'U2(m, l), m â‰¥ 1, l â‰¥ 2',
        'U3': 'U3(m), m â‰¥ 1',
        'SVG': 'Single-vertex graph',
        'Spq': 'S(p, q), p â‰¥ 1, q â‰¥ 2',
        'S2': 'S2(p1, q1, . . . , pm, qm), m â‰¥ 2 and p1 > p2 > . . . > pm',
        'S3': 'S3(p, q1, q2) p â‰¥ 1, q1 â‰¥ 2, q2 â‰¥ 1',
        'S4': 'S4(p, q) p â‰¥ 1, q â‰¥ 1',
        'PreviousResult': 'Previous Result'
      };

      const TRANSFORMATION_OPTIONS = {
        'standard': 'Standard',
        'inverse': 'Inverse',
        'complement': 'Complement',
        'inverseComplement': 'Complement of Inverse'
      };

      // Generate HTML for input fields dynamically
      function generateInputHTML(inputType, graph_num) {
        const inputLabels = {
          'p': 'Enter p:',
          'l': 'Enter l:',
          'q': 'Enter q:',
          'q1': 'Enter q1:',
          'q2': 'Enter q2:',
          'm': 'Enter m:',
          'partition': 'Vertex location:'
        };

        // Special handling for partition dropdown
        if (inputType === 'partition') {
          return `
            <div id="input-${inputType}-${graph_num}" class="hidden">
              <label for="${inputType}-${graph_num}">${inputLabels[inputType]}</label>
              <select id="${inputType}-${graph_num}" name="${inputType}" onchange="updateDegreeSequenceDisplay(${graph_num})">
                <option value="A">Partition A</option>
                <option value="B">Partition B</option>
              </select>
            </div>
          `;
        }

                const minValues = {
          'p': 1, 'l': 1, 'q': 1, 'q1': 1, 'q2': 1, 'm': graph_num === 1 ? 2 : 1
        };

        const onchange = inputType === 'm' ? ` onchange="showInputsS2(${graph_num}); updateDegreeSequenceDisplay(${graph_num})"` : ` oninput="updateDegreeSequenceDisplay(${graph_num})"`;

        return `
          <div id="input-${inputType}-${graph_num}" class="hidden">
            <label for="${inputType}-${graph_num}">${inputLabels[inputType]}</label>
            <input type="number" id="${inputType}-${graph_num}" name="${inputType}" min="${minValues[inputType]}"${onchange}>
          </div>
        `;
      }

      function generateSelectHTML(graph_num) {
        const options = GRAPH_OPTIONS[graph_num].map(type => {
          // Disable PreviousResult option initially until there's a result
          const disabled = (type === 'PreviousResult' && previousResult === null) ? ' disabled' : '';
          let label = GRAPH_LABELS[type];

          // Add the formatted result to the PreviousResult label when available
          if (type === 'PreviousResult' && previousResult) {
            label += ': ' + formatResult(previousResult);
          }

          return `<option value="${type}"${disabled}>${label}</option>`;
        }).join('');

        return `
          <select id="graph-type-${graph_num}" name="graph-type-${graph_num}" onchange="showInputs(${graph_num})">
            ${options}
          </select>
        `;
      }

      function generateTransformationHTML(graph_num) {
        const options = Object.keys(TRANSFORMATION_OPTIONS).map(type =>
          `<option value="${type}">${TRANSFORMATION_OPTIONS[type]}</option>`
        ).join('');

        return `
          <div style="margin-top: 10px;">
            <label for="transformation-${graph_num}">Transformation:</label>
            <select id="transformation-${graph_num}" name="transformation-${graph_num}" onchange="updateDegreeSequenceDisplay(${graph_num})">
              ${options}
            </select>
          </div>
        `;
      }

      function generateGraphContainerHTML(graph_num) {
        const inputTypes = ['p', 'l', 'q', 'q1', 'q2', 'm', 'partition'];
        const inputsHTML = inputTypes.map(type => generateInputHTML(type, graph_num)).join('');

        return `
          <div class="graph-section">
            <h3>Graph ${graph_num}</h3>
            <div class="static_height">
              ${generateSelectHTML(graph_num)}
              ${generateTransformationHTML(graph_num)}
              ${inputsHTML}
              <div id="dynamic-p-inputs-${graph_num}" class="hidden">
                <!-- Dynamic p1 through pm inputs will be created here -->
              </div>
              <div id="dynamic-q-inputs-${graph_num}" class="hidden">
                <!-- Dynamic q1 through qm inputs will be created here -->
              </div>
              <div id="previous-result-display-${graph_num}" class="hidden" style="margin-top: 10px; padding: 8px; background-color: #e8f4fd; border: 1px solid #bee5eb; border-radius: 4px;">
                <strong>Using Previous Result:</strong>
                <div id="previous-result-text-${graph_num}" style="font-family: monospace; margin-top: 5px;"></div>
              </div>
              <div style="margin-top: 15px;">
                <div id="graph-${graph_num}-sequence-label">Graph ${graph_num} Degree Sequence:</div><br>
                <div id="graph-${graph_num}-sequence" aria-labelledby="graph-${graph_num}-sequence-label" style="width: 440px; min-height: 20px; font-family: monospace; background-color: #f5f5f5; border: 1px solid #ccc; padding: 10px; border-radius: 4px; color: #666;" data-placeholder="Configure graph parameters to see degree sequence..."></div>
              </div>
            </div>
          </div>
        `;
      }

      function initializeHTML() {
        const dropdownContainer = document.querySelector('.dropdown-container');
        dropdownContainer.innerHTML = `
          ${generateGraphContainerHTML(1)}
          ${generateGraphContainerHTML(2)}
        `;

        showInputs(1);
        showInputs(2);

        // Initialize display divs with placeholder text
        const resultDivShort = document.getElementById('composition-result-short');
        // const resultDivLong = document.getElementById('composition-result-long');
        const graph1Div = document.getElementById('graph-1-sequence');
        const graph2Div = document.getElementById('graph-2-sequence');

        setDisplayContent(resultDivShort, "");
        // setDisplayContent(resultDivLong, "");
        setDisplayContent(graph1Div, "");
        setDisplayContent(graph2Div, "");

        // Update degree sequence displays
        updateDegreeSequenceDisplay(1);
        updateDegreeSequenceDisplay(2);
      }

      function hideAndClearInput(element, inputId) {
        element.classList.add('hidden');
        const inputElement = document.getElementById(inputId);
        if (inputElement.tagName === 'SELECT') {
          inputElement.selectedIndex = 0; // Reset to first option
        } else {
          inputElement.value = "";
        }
      }

      function showInputElement(inputType, graph_num) {
        const element = document.getElementById(`input-${inputType}-${graph_num}`);
        if (element) element.classList.remove('hidden');
      }

      function hideAllInputs(graph_num) {
        const inputTypes = ['m', 'l', 'p', 'q', 'q1', 'q2', 'partition'];
        inputTypes.forEach(type => {
          const element = document.getElementById(`input-${type}-${graph_num}`);
          if (element) hideAndClearInput(element, `${type}-${graph_num}`);
        });

        const dynamicP = document.getElementById(`dynamic-p-inputs-${graph_num}`);
        const dynamicQ = document.getElementById(`dynamic-q-inputs-${graph_num}`);
        const previousResultDisplay = document.getElementById(`previous-result-display-${graph_num}`);

        if (dynamicP) {
          dynamicP.classList.add('hidden');
          dynamicP.innerHTML = "";
        }

        if (dynamicQ) {
          dynamicQ.classList.add('hidden');
          dynamicQ.innerHTML = "";
        }

        if (previousResultDisplay) {
          previousResultDisplay.classList.add('hidden');
        }
      }

      function getParameterValues(graph_num) {
        const params = {};
        const inputTypes = ['m', 'l', 'p', 'q', 'q1', 'q2'];

        inputTypes.forEach(type => {
          const element = document.getElementById(`${type}-${graph_num}`);
          params[type] = element ? Number(element.value) : undefined;
        });

        // Handle partition parameter separately since it's a string, not a number
        const partitionElement = document.getElementById(`partition-${graph_num}`);
        params.partition = partitionElement ? partitionElement.value : undefined;

        return params;
      }

      function areAllRequiredParamsFilled(graphType, graph_num) {
        const config = GRAPH_CONFIG[graphType];
        if (!config) return false;

        // PreviousResult requires an existing previousResult
        if (graphType === 'PreviousResult') {
          return previousResult !== null;
        }

        // Check static inputs declared for the graph type
        if (config.inputs && config.inputs.length > 0) {
          for (const input of config.inputs) {
            const el = document.getElementById(`${input}-${graph_num}`);
            if (!el) return false;
            if (input === 'partition') {
              if (el.value !== 'A' && el.value !== 'B') return false;
            } else {
              if (el.value === '' || el.value === null || el.value === undefined) return false;
            }
          }
        }

        // Special handling for S2 dynamic inputs (p1..pm, q1..qm)
        if (graphType === 'S2') {
          const mEl = document.getElementById(`m-${graph_num}`);
          if (!mEl || mEl.value === '' || isNaN(Number(mEl.value))) return false;
          const M = parseInt(mEl.value, 10);
          if (!Number.isFinite(M) || M < 1) return false;
          for (let i = 1; i <= M; i++) {
            const pEl = document.getElementById(`s2-p${i}-${graph_num}`);
            const qEl = document.getElementById(`s2-q${i}-${graph_num}`);
            if (!pEl || !qEl) return false;
            if (pEl.value === '' || qEl.value === '') return false;
          }
        }

        return true;
      }

      function showInputs(graph_num) {
        const selection = document.getElementById('graph-type-' + graph_num).value;
        const config = GRAPH_CONFIG[selection];

        // Hide all inputs first
        hideAllInputs(graph_num);

        // Special handling for Previous Result
        if (selection === 'PreviousResult') {
          const previousResultDisplay = document.getElementById(`previous-result-display-${graph_num}`);
          const previousResultText = document.getElementById(`previous-result-text-${graph_num}`);

          if (previousResultDisplay && previousResult) {
            previousResultDisplay.classList.remove('hidden');
            setDisplayContent(previousResultText, formatResult(previousResult));
          }
        } else {
          // Show required inputs based on configuration
          if (config && config.inputs) {
            config.inputs.forEach(inputType => {
              showInputElement(inputType, graph_num);
            });
          }
        }

        // Update degree sequence display
        updateDegreeSequenceDisplay(graph_num);
      }

      function updateDegreeSequenceDisplay(graph_num) {
        const displayDiv = document.getElementById(`graph-${graph_num}-sequence`);
        if (!displayDiv) return;

        try {
          const graphType = document.getElementById(`graph-type-${graph_num}`).value;
          const transformationType = document.getElementById(`transformation-${graph_num}`).value;

          // Only compute when all required fields are filled
          if (!areAllRequiredParamsFilled(graphType, graph_num)) {
            document.getElementById(`graph-${graph_num}-sequence`).innerHTML = "";
            return;
          }

          // Get parameter values for the new signature
          const params = getParameterValues(graph_num);
          let degreeSequence = getDegreeSequence(graphType, params, graph_num);
          if (degreeSequence) {
            // Apply transformation
            degreeSequence = applyTransformation(degreeSequence, transformationType, graphType);
            if (degreeSequence) {
              const text = generateText(degreeSequence);
              displayDiv.innerHTML = text;
            } else {
              displayDiv.innerHTML = "";
            }
          } else {
            displayDiv.innerHTML = "";
          }
        } catch (error) {
          console.error('updateDegreeSequenceDisplay error:', error);
          // If there's an error (incomplete configuration), show placeholder
          displayDiv.innerHTML = "";
        }
      }

      function generateText(degreeSequence) {
        const [isGraphUnigraph, uniLabel, uniType, uniParams, newDegreeSequence] = isComponent(degreeSequence);
        let degreeSequenceText = formatResult(newDegreeSequence || degreeSequence);
        const hasCompactedParam = uniParams.compacted !== undefined;
        const isCompacted = hasCompactedParam && uniParams.compacted;
        const paramsString = paramsText(uniParams);
        const hasParams = paramsString != "";
        const distinguishingNumberResult = distinguishingNumber(uniLabel, uniType, uniParams, newDegreeSequence);
        const hasDistinguishingNumber = distinguishingNumberResult !== undefined;
        const typeString = typeText(uniType, uniLabel, isCompacted);
        return `${typeString}${paramsString}Degree Sequence: ${degreeSequenceText}<br>${hasDistinguishingNumber ? `Distinguishing Number: ${distinguishingNumberResult}` : ""}`;
      }

      function typeText(uniType, uniLabel, isCompacted) {
        const hasType = uniType != "None";
        const hasLabel = uniLabel != "None";
        if (hasType) {
          let text = `Type: `;
          text += isCompacted ? "Compacted " : "";
          text += hasLabel ? `${uniLabel} ` : "";
          text += hasType ? `${uniType}` : "";
          text += "<br>";
          return text;
        } else {
          return "";
        }
      }

      function paramsText(uniParams) {
        let paramsString = "";
        if (uniParams !== "None") {
          Object.entries(uniParams).forEach(([key, value]) => {
            if (key == "compacted") {
              return;
            }
            if (Array.isArray(value)) {
              value.forEach((v, index) => {
                if (index == 0) {
                  // nothing
                } else {
                  paramsString += `${key}${index}: ${v}, `;
                }
              });
            } else {
              paramsString += `${key}: ${value}, `;
            }
          });
          paramsString = "Params: " + paramsString + "<br>";
        }
        return paramsString;
      }

      function distinguishingNumber(uniLabel, uniType, uniParams, degreeSequence) {
        const type = GRAPH_CONFIG[uniLabel];
        if (!type) return undefined;
        switch (uniLabel) {
          case 'C5':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber();
          case 'mK2':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber(uniParams.m);
          case 'U2':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber(uniParams.m, uniParams.l);
          case 'U3':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber(uniParams.m);
          case 'Spq':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber(uniParams.p, uniParams.q);
          case 'S2':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber(uniParams);
          case 'S3':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber(uniParams.p, uniParams.q1, uniParams.q2);
          case 'S4':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber(uniParams.p, uniParams.q);
          case 'SVG':
            return GRAPH_CONFIG[uniLabel].distinguishingNumber(degreeSequence);
          default:
            return undefined;
        }
      }

      function setDisplayContent(element, content) {
        if (content && content.trim() !== "") {
          element.textContent = content;
          element.style.color = "#000";
        } else {
          element.textContent = element.dataset.placeholder || "";
          element.style.color = "#999";
        }
      }

      function showInputsS2(graph_num) {
        const selection = document.getElementById('graph-type-' + graph_num).value;
        if (selection != "S2") {
          return;
        }
        const mValue = document.getElementById('m-' + graph_num).value;
        const m = parseInt(mValue);

        // Clear existing dynamic inputs
        const DYNAMIC_P = document.getElementById('dynamic-p-inputs-' + graph_num);
        const DYNAMIC_Q = document.getElementById('dynamic-q-inputs-' + graph_num);

        if (DYNAMIC_P) {
          DYNAMIC_P.innerHTML = '';
          DYNAMIC_P.classList.add('hidden');
        }

        if (DYNAMIC_Q) {
          DYNAMIC_Q.innerHTML = '';
          DYNAMIC_Q.classList.add('hidden');
        }

        if (m && m >= 1) {
          // Create p1 through pm inputs
          for (let i = 1; i <= m; i++) {
            const inputDiv = document.createElement('div');
            inputDiv.innerHTML = `
              <label for="s2-p${i}-${graph_num}">Enter p${i}:</label>
              <input type="number" id="s2-p${i}-${graph_num}" name="p${i}" min="1" oninput="updateDegreeSequenceDisplay(${graph_num})">
            `;
            DYNAMIC_P.appendChild(inputDiv);
          }

          // Create q1 through qm inputs
          for (let i = 1; i <= m; i++) {
            const inputDiv = document.createElement('div');
            inputDiv.innerHTML = `
              <label for="s2-q${i}-${graph_num}">Enter q${i}:</label>
              <input type="number" id="s2-q${i}-${graph_num}" name="q${i}" min="1" oninput="updateDegreeSequenceDisplay(${graph_num})">
            `;
            DYNAMIC_Q.appendChild(inputDiv);
          }

          DYNAMIC_P.classList.remove('hidden');
          DYNAMIC_Q.classList.remove('hidden');
        } else {
          DYNAMIC_P.classList.add('hidden');
          DYNAMIC_Q.classList.add('hidden');
        }
      }

      function applyTransformation(degreeSequence, transformationType, graphType) {
        switch (transformationType) {
          case 'standard':
            return degreeSequence;
          case 'inverse':
            return calculateInverse(degreeSequence);
          case 'complement':
            return calculateComplement(degreeSequence);
          case 'inverseComplement':
            const inverse = calculateInverse(degreeSequence);
            return calculateComplement(inverse);
          default:
            return degreeSequence;
        }
      }

      function computeComposition() {
        const g1 = document.getElementById('graph-type-1').value;
        const g2 = document.getElementById('graph-type-2').value;
        const t1 = document.getElementById('transformation-1').value;
        const t2 = document.getElementById('transformation-2').value;

        alert(`Composing: ${TRANSFORMATION_OPTIONS[t1]} ${g1} and ${TRANSFORMATION_OPTIONS[t2]} ${g2}`);

        const params1 = getParameterValues(1);
        const params2 = getParameterValues(2);
        if (!checkValidity(g1, params1, 1) || !checkValidity(g2, params2, 2)) {
          return; // Don't proceed if validation failed
        }

        let g = getDegreeSequence(g1, params1, 1);
        let h = getDegreeSequence(g2, params2, 2);

        // Check if validation failed for either graph
        if (g === null || h === null) {
          return; // Don't proceed if validation failed
        }

        // Apply transformations
        g = applyTransformation(g, t1, g1);
        h = applyTransformation(h, t2, g2);

        if (g === null || h === null) {
          return;
        }

        const result = compose(g, h);
        previousResult = result;

        // Display result in the result div
        const resultDivShort = document.getElementById('composition-result-short');
        setDisplayContent(resultDivShort, formatResult(result));
        // const resultDivLong = document.getElementById('composition-result-long');
        // setDisplayContent(resultDivLong, longFormatResult(result));

        // Enable the PreviousResult option in dropdown 1 and update its label
        const dropdown1 = document.getElementById('graph-type-1');
        const previousResultOption = dropdown1.querySelector('option[value="PreviousResult"]');
        if (previousResultOption) {
          previousResultOption.disabled = false;
          previousResultOption.textContent = 'Previous Result: ' + formatResult(previousResult);
        }

                  // Update any visible previous result displays
          for (let i = 1; i <= 2; i++) {
            const dropdown = document.getElementById(`graph-type-${i}`);
            if (dropdown && dropdown.value === 'PreviousResult') {
              const previousResultText = document.getElementById(`previous-result-text-${i}`);
              if (previousResultText) {
                setDisplayContent(previousResultText, formatResult(previousResult));
              }
            }
          }
              }

      function getDegreeSequence(type, params, graph_num) {
        const { m: M, l: L, p: P, q: Q, q1: Q1, q2: Q2 } = params;

        // For S2, collect dynamic pi and qi values and calculate n
        if (type === 'S2' && M) {
          for (let i = 1; i <= M; i++) {
            // Collect pi values
            const pElement = document.getElementById(`s2-p${i}-${graph_num}`);
            if (pElement) {
              params[`p${i}`] = Number(pElement.value);
            }

            // Collect qi values and sum them for n
            const qElement = document.getElementById(`s2-q${i}-${graph_num}`);
            if (qElement) {
              const qValue = Number(qElement.value);
              params[`q${i}`] = qValue;
            }
          }
        }

        const config = GRAPH_CONFIG[type];
        if (!config) {
          alert("Unknown graph type: " + type);
          return null;
        }

        return config.degSequence(params);
      }

      function checkValidity(type, params, graph_num) {
        const { m: M, l: L, p: P, q: Q, q1: Q1, q2: Q2 } = params;
        const config = GRAPH_CONFIG[type];
        if (!config) {
          alert("Unknown graph type: " + type);
          return false;
        }

        function isValidNumber(value, min) {
          return value !== null && value !== undefined && value !== "" && !isNaN(value) && Number(value) >= min;
        }

        const paramValues = { m: M, l: L, p: P, q: Q, q1: Q1, q2: Q2 };

        // Validate standard parameters
        for (const validation of config.validation) {
          const value = paramValues[validation.param];
          const displayName = validation.displayName || validation.param;

          if (!isValidNumber(value, validation.min)) {
            alert(`${displayName} must be defined and at least ${validation.min} for ${validation.name}`);
            return false;
          }
        }

        // Special handling for S2 dynamic inputs
        if (type === 'S2') {
          const pValues = [];
          const qValues = [];

          // Validate p1 through pm
          for (let i = 1; i <= M; i++) {
            const pElement = document.getElementById(`s2-p${i}-${graph_num}`);
            if (!pElement) {
              alert(`p${i} input not found for S2`);
              return false;
            }
            const pValue = Number(pElement.value);
            if (!isValidNumber(pValue, 1)) {
              alert(`p${i} must be defined and at least 1 for S2`);
              return false;
            }
            pValues.push(pValue);
          }

          // Validate q1 through qm
          for (let i = 1; i <= M; i++) {
            const qElement = document.getElementById(`s2-q${i}-${graph_num}`);
            if (!qElement) {
              alert(`q${i} input not found for S2`);
              return false;
            }
            const qValue = Number(qElement.value);
            if (!isValidNumber(qValue, 1)) {
              alert(`q${i} must be defined and at least 1 for S2`);
              return false;
            }
            qValues.push(qValue);
          }

          // Check that p1 > p2 > ... > pm
          for (let i = 0; i < pValues.length - 1; i++) {
            if (pValues[i] <= pValues[i + 1]) {
              alert(`p values must be in descending order: p${i + 1} > p${i + 2} > ... > p${M} for S2`);
              return false;
            }
          }
        }

        return true;
      }

      function calculateSizeOfHA(h) {
        if (h.A !== undefined) {
          return Object.values(h.A).reduce((sum, val) => sum + val, 0);
        } else {
          return Object.values(h).reduce((sum, val) => sum + val, 0);
        }
      }

      function calculateSizeOfGraph(g) {
        if (g.A !== undefined) {
          return Object.values(g.A).reduce((sum, val) => sum + val, 0) + Object.values(g.B).reduce((sum, val) => sum + val, 0);
        } else {
          return Object.values(g).reduce((sum, val) => sum + val, 0);
        }
      }

      function composeG(g, h) {
        let transformedGraph = {};
        const sizeOfHA = calculateSizeOfHA(h);
        if (g.A !== undefined) {
          transformedGraph.A = {};
          transformedGraph.B = {};
          Object.entries(g.A).forEach(([k, v]) => {
            transformedGraph.A[parseInt(k) + sizeOfHA] = v;
          });
          Object.entries(g.B).forEach(([k, v]) => {
            transformedGraph.B[parseInt(k) + sizeOfHA] = v;
          });
        } else {
          Object.entries(g).forEach(([k, v]) => {
            transformedGraph[parseInt(k) + sizeOfHA] = v;
          });
        }
        return transformedGraph;
      }

      function composeH(g, h) {
        let transformedGraph = {};
        transformedGraph.A = {};
        transformedGraph.B = {};
        const sizeOfG = calculateSizeOfGraph(g);
        Object.entries(h.A).forEach(([k, v]) => {
          transformedGraph.A[parseInt(k) + sizeOfG] = v;
        });
        Object.entries(h.B).forEach(([k, v]) => {
          transformedGraph.B[parseInt(k)] = v;
        });
        return transformedGraph;
      }

      function combinedGraphs(g, h) {
        // if they both have A, then we need to combine them
        if (g.A !== undefined && h.A !== undefined) {
          return combineGraphs([g.A, h.A, g.B, h.B]);
        } else {
          return combineGraphs([g, h.A, h.B]);
        }
      }

      function combineGraphs(graphs) {
        const validGraphs = graphs.filter(graph => graph !== undefined);
        const combined = {};
        validGraphs.forEach(graph => {
          Object.entries(graph).forEach(([k, v]) => {
            if (combined[k] !== undefined) {
              combined[k] += v;
            } else {
              combined[k] = v;
            }
          });
        });
        return combined;
      }

      function composeGraphs(graphs) {
        let finalResult;

        if (graphs.length === 3) {
          const firstComposition = compose(graphs[0], graphs[1]);
          finalResult = compose(firstComposition, graphs[2]);
        } else {
          finalResult = compose(graphs[0], graphs[1]);
        }
        return finalResult;
      }

      function compose(g, h) {
        const composedG = composeG(g, h);
        const composedH = composeH(g, h);

        return combinedGraphs(composedG, composedH);
      }

      function formatHashmap(hashmap) {
        if (hashmap === undefined) {
          return "";
        }
        let resultString = "";
        const numKeys = Object?.keys(hashmap)?.length;
        Object?.keys(hashmap)?.sort((a, b) => b - a).forEach((key, index) => {
          resultString += `${key}^${hashmap[key]} `;
          if (index !== numKeys - 1) {
            resultString += ", ";
          }
        });
        return resultString;
      }

      function longFormatResult(result) {
        if (result === undefined) {
          return "";
        }

        if (result.A !== undefined || result.B !== undefined) {
          let resultString = "";
          resultString += longFormatResult(result.A);
          resultString += "; ";
          resultString += longFormatResult(result.B);
          return resultString;
        } else {
          return longFormatResult(result);
        }
      }

      function longFormatResult(result) {
        if (result === undefined) {
          return "";
        }
        let resultString = "";
        const keys = Object.keys(result);
        keys.sort((a, b) => b - a);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = result[key];
          for (let j = 1; j <= value; j++) {
            resultString += `${key}`;
            if (j !== value || i !== keys.length - 1) {
              resultString += ", ";
            }
          }
        }
        return resultString;
      }

      function formatResult(result) {
        if (result === undefined) {
          return "";
        }

        if (result === null) {
          return "null";
        }

        // Handle split graphs (with A and B partitions)
        if (result.A !== undefined || result.B !== undefined) {
          let resultString = "";
          resultString += formatHashmap(result.A);
          resultString += "; ";
          resultString += formatHashmap(result.B);
          return resultString;
        } else {
          // Handle simple degree sequences
          return formatHashmap(result);
        }
      }

      function showComposeUnigraphs() {
        document.getElementById('random-unigraph-generator').classList.add('hidden');
        document.getElementById('decompose-graph').classList.add('hidden');
        document.getElementById('compose-graphs').classList.add('hidden');
        document.getElementById('compose-unigraphs').classList.remove('hidden');
      }

      function showRandomUnigraphGenerator() {
        document.getElementById('compose-unigraphs').classList.add('hidden');
        document.getElementById('decompose-graph').classList.add('hidden');
        document.getElementById('compose-graphs').classList.add('hidden');
        document.getElementById('random-unigraph-generator').classList.remove('hidden');
      }

      function showDecompose() {
        document.getElementById('compose-unigraphs').classList.add('hidden');
        document.getElementById('random-unigraph-generator').classList. add('hidden');
        document.getElementById('compose-graphs').classList.add('hidden');
        document.getElementById('decompose-graph').classList.remove('hidden');
      }

      function showComposeGraphs() {
        document.getElementById('compose-unigraphs').classList.add('hidden');
        document.getElementById('random-unigraph-generator').classList.add('hidden');
        document.getElementById('decompose-graph').classList.add('hidden');
        document.getElementById('compose-graphs').classList.remove('hidden');
      }

      function computeRandomUnigraph() {
        for (let i = 1; i <= 3; i++) {
          const resultDiv = document.getElementById(`random-unigraph-${i}`);
          if (resultDiv) {
            resultDiv.innerHTML = "";
          }
        }
        const numVertices = document.getElementById('num-vertices').value;
        const numGraphs = document.getElementById('num-graphs').value;
        const vertice_partitions = partitionVertices(numVertices, numGraphs);
        const graphs = [];
        for (let i = 0; i < vertice_partitions.length; i++) {
          const partitionNumVertices = i === 0 ? vertice_partitions[i] : vertice_partitions[i] - vertice_partitions[i - 1];
          const randomUnigraph = i === 0 ? generateRandomUnigraph(partitionNumVertices, false) : generateRandomUnigraph(partitionNumVertices);
          graphs.push(randomUnigraph.degreeSequence);

          // Display each random unigraph in its respective text box
          const resultDiv = document.getElementById(`random-unigraph-${i + 1}`);
          if (resultDiv) {
            const label = `graph ${i + 1}`;
            const numVerticesText = `number of vertices: ${partitionNumVertices}`;
            const typeText = `type: ${randomUnigraph.graphType}`;
            const paramsText = `${Object.entries(randomUnigraph.params).map(([param, value]) => {
              return `${param}: ${value}`;
            }).join(', ')}`;
            const degreeSequenceText = `degree sequence: ${formatResult(randomUnigraph.degreeSequence)}`;
            const text = paramsText ? `${label}<br>${numVerticesText}<br>${typeText}<br>${paramsText}<br>${degreeSequenceText}` : `${label}<br>${numVerticesText}<br>${typeText}<br>${degreeSequenceText}`;
            resultDiv.innerHTML = text;
          }
        }

        const finalResult = composeGraphs(graphs);
        const compositionResultDiv = document.getElementById('final-result-short');
        // const compositionResultDivLong = document.getElementById('final-result-long');
        if (compositionResultDiv) {
          compositionResultDiv.innerHTML = `final result: ${formatResult(finalResult)}`;
          // compositionResultDivLong.innerHTML = `final result long: ${longFormatResult(finalResult)}`;
        }
      }

      function partitionVertices(numVertices, numGraphs) {
        const numPartitions = numGraphs - 1;
        const range = numVertices - 1;
        const partitions = [];
        while (partitions.length < numPartitions) {
          const partition = Math.floor(Math.random() * range) + 1;
          if (!partitions.includes(partition)) {
            partitions.push(partition);
          }
        }
        partitions.push(numVertices);
        return partitions.sort((a, b) => a - b);
      }

      function generateRandomUnigraph(numVertices, split = true) {
        let degreeSequence = {};
        const potentialGraphTypes = calculatePotentialGraphs(numVertices, split);
        const graphType = potentialGraphTypes[Math.floor(Math.random() * potentialGraphTypes.length)];
        if (graphType === undefined) {
          return null;
        }
        const potentialParams = GRAPH_CONFIG[graphType].potentialParamsByNumVertices(numVertices);
        const params = potentialParams[Math.floor(Math.random() * potentialParams.length)];
        degreeSequence = GRAPH_CONFIG[graphType].degSequence(params);
        return {graphType: graphType, params: params, degreeSequence: degreeSequence};
      }

      function calculatePotentialGraphs(numVertices, split) {
        const potentialGraphs = [];
        for (const graphType in GRAPH_CONFIG) {
          if (split && !GRAPH_CONFIG[graphType].split) {
            continue;
          }
          if (GRAPH_CONFIG[graphType]?.potentialVertices?.includes(numVertices)) {
            potentialGraphs.push(graphType);
          }
        }
        return potentialGraphs;
      }

      function enumerateParamsForTotal(T) {
        if (T < 2) return []; // no solutions

        const results = [];

        // Backtrack integer partitions of T with parts >= 2, nonincreasing
        function gen(remaining, maxPart, parts) {
          if (remaining === 0) {
            results.push(parts.slice()); // one partition
            return;
          }
          for (let x = Math.min(maxPart, remaining); x >= 2; x--) {
            parts.push(x);
            gen(remaining - x, x, parts);
            parts.pop();
          }
        }

        gen(T, T, []);

        // Convert each partition to (m, p_i, q_i, n, A, B)
        const solutions = results.map(parts => {
          // Count multiplicities: r -> q
          const counts = new Map();
          for (const s of parts) counts.set(s, (counts.get(s) || 0) + 1);

          // Distinct r_i in strict descending order; p_i = r_i - 1; q_i = multiplicity
          const rList = Array.from(counts.keys()).sort((a, b) => b - a);
          const m = rList.length;
          const p = rList.map(r => r - 1);
          const q = rList.map(r => counts.get(r));

          // n = sum q_i
          const n = q.reduce((a, b) => a + b, 0);

          // Build A and B exactly as your degSequence would
          const A = {};
          const B = {};
          let B1 = 0;
          for (let i = 0; i < m; i++) {
            const pi = p[i];
            const qi = q[i];
            A[pi + n - 1] = (A[pi + n - 1] || 0) + qi; // should be unique key per i
            B1 += pi * qi;
          }
          B[1] = B1; // equals T - n

          // Also return params in your naming convention
          const params = { m };
          for (let i = 0; i < m; i++) {
            params[`p${i + 1}`] = p[i];
            params[`q${i + 1}`] = q[i];
          }

          return params;
        });

        return solutions;
      }

      function formatComponents(components) {
        let result = "";
        let index = 1;
        components.forEach(component => {
          result += `Component ${index}:<br>${generateText(component)}`;
          if (index < components.length) {
            result += "<br><br>";
          }
          index++;
        });
        return result;
      }

      function convertToHashmap(component) {
        if (component == "") {
          return {};
        }

        const degreeArray = component.split(', ');
        const hashmap = {};

        for (let i = 0; i < degreeArray.length; i++) {
          const degree = degreeArray[i];
          hashmap[degree] = hashmap[degree] + 1 || 1;
        }
        return hashmap;
      }

      function convertGraphToHashmap(component) {
        if (component.includes('; ')) {
          const left = component.split('; ')[0];
          const right = component.split('; ')[1];
          return {A: convertToHashmap(left), B: convertToHashmap(right)};
        } else {
          return convertToHashmap(component);
        }
      }

      function decomposeGraph() {
        const input = document.getElementById('decompose-graph-input').value;
        const components = decompose(input);
        const hashComponents = components.map(component => convertGraphToHashmap(component));
        const reversedHashComponents = hashComponents.reverse();
        const minimalComponents = minimalDecompose(reversedHashComponents);
        const formattedComponents = formatComponents(minimalComponents);
        document.getElementById('decompose-graph-result').innerHTML = formattedComponents;
      }

      function minimalDecompose(hashComponents) {
        let combinedComponents = [];
        for (let index = 0; index < hashComponents.length; index++) {
          const component = hashComponents[index];
          if (component.A !== undefined && index > 0) {
            const previousComponent = hashComponents[index - 1];
            const current = isComponent(component);
            const previous = isComponent(previousComponent);
            const currentType = current[1];
            const previousType = previous[1];
            if (currentType == "SVG" && previousType == "SVG" ) {
              if (index === 1) {
                combinedComponents.push(combineSVGs(previousComponent, component));
              }
              const currentParams = current[3];
              const previousParams = previous[3];
              if (currentParams.partition == previousParams.partition) {
                const previousCombinedComponent = combinedComponents[combinedComponents.length - 1];
                const combined = combineSVGs(previousCombinedComponent, component);
                combinedComponents[combinedComponents.length - 1] = combined;
              } else {
                combinedComponents.push(component);
              }
            } else {
              combinedComponents.push(component);
            }
          } else {
            combinedComponents.push(component);
          }
        }
        return combinedComponents;
      }

      function combineSVGs(firstComponent, secondComponent) {
        if (firstComponent.A !== undefined && secondComponent.A !== undefined) {
          const firstA = firstComponent.A;
          if (Object.keys(firstA).length !== 1) {
            return null;
          }
          const firstNumDegrees = Object.keys(firstA)[0];
          const firstNumVertices = Object.values(firstA)[0];
          const newComponent = {A: {[Number(firstNumDegrees) + 1]: firstNumVertices + 1}, B: {}};
          return newComponent;
        }
        if (firstComponent.B !== undefined && secondComponent.B !== undefined) {
          if (Object.keys(firstB).length !== 1) {
            return null;
          }
          const firstNumDegrees = Object.keys(firstB)[0];
          const firstNumVertices = Object.values(firstB)[0];
          const newComponent = {A: {}, B: {0: Number(firstNumVertices) + 1}};
          return newComponent;
        }
        if (firstComponent.A !== undefined && secondComponent.B !== undefined) {
          return {A: {}, B: {0: 2}};
        }
        if (firstComponent.B !== undefined && secondComponent.A !== undefined) {
          return {A: {1: 2}, B: {}};
        }
      }

      function decompose(input) {
        const d = convertToDegSequence(input);
        let i = 0;
        let j = Object.keys(d).length;
        let b = 0;
        let s = [];
        while (i < j) {
          if (j - i == 1) {
            s.push("0");
            return s;
          }
          const bestPair = findBestPair(d, i, j, b);
          let p = bestPair[0];
          let q = bestPair[1];
          if (p == -1 && q == -1) {
            let text = "";
            for (let x = i + 1; x <= j; x++) {
              text += `${d[x] - b}`;
              if (x !== j) {
                text += ", ";
              }
            }
            s.push(text)
            return s;
          } else  if ( p == 0 && q == 1) {
            s.push("; 0")
          } else if (p == 1 && q == 0) {
            s.push("0; ")
          } else {
            let a = j - i - p - q;
            let left = "";
            for (let y = i + 1; y <= i + p; y++) {
              left += `${d[y] - b - a}`;
              if (y !== i + p) {
                left += ", ";
              }
            }
            let right = "";
            for (let y = j - q + 1; y <= j; y++) {
              right += `${d[y] - b}`;
              if (y !== j) {
                right += ", ";
              }
            }
            s.push(`${left}; ${right}`)
          }
          i = i + p;
          j = j - q;
          b = b + p;
        }
        return s;
      }

      function convertToDegSequence(input) {
        const result = {};
        const inputArray = input.split(', ');
        let index = 1;
        for (let i = 0; i < inputArray.length; i++) {
          const [degree, count] = inputArray[i].split('^');
          for (let j = 0; j < count; j++) {
            result[index] = degree;
            index++;
          }
        }
        return result;
      }

      function findBestPair(d, i, j, b) {
        let m = j - i;
        let d_prime = {};
        for (let t = 1; t <= m; t++) {
          d_prime[t] = d[i + t] - b;
        }
        if (d_prime[m] == 0) {
          return [0, 1];
        } else if (d_prime[1] == m - 1) {
          return [1, 0];
        } else {
          let p = 1;
          let q = 0;
          let front_sum = d_prime[1];
          let back_sum = 0;
          while (p + q < m && front_sum != (p * (m - q - 1)) + back_sum) {
            p++;
            front_sum += d_prime[p];
            while (p + q < m && d_prime[m - q] < p) {
              q++;
              back_sum += d_prime[m - q + 1];
            }
          }
          if (p + q < m && front_sum == (p * (m - q - 1)) + back_sum) {
            return [p, q];
          } else {
            return [-1, -1];
          }
        }
      }

      function convertStringToHashmap(input) {
        if (input.includes('; ')) {
          const left = input.split('; ')[0];
          const right = input.split('; ')[1];
          return {A: convertStringToHashmap(left), B: convertStringToHashmap(right)};
        } else {
          const inputArray = input.split(', ');
          const hashmap = {};
          for (let i = 0; i < inputArray.length; i++) {
            const [degree, count] = inputArray[i].split('^');
            hashmap[degree] = Number(count);
          }
          return hashmap;
        }
      }

      function graphComposition() {
        const input1 = document.getElementById('compose-graphs-input-1').value;
        const input2 = document.getElementById('compose-graphs-input-2').value;
        const degSequence1 = convertStringToHashmap(input1);
        const degSequence2 = convertStringToHashmap(input2);
        const result = compose(degSequence1, degSequence2);
        document.getElementById('compose-graphs-result').innerHTML = formatResult(result);
      }

      function isComponent(input) {
        const splitGraph = isSplitGraph(input);
        const splitGraphResult = splitGraph[0];
        const newInput = splitGraph[1];
        if (splitGraphResult) {
          const standardSplitComponent = isSplitComponent(newInput);
          const standardSplitComponentResult = standardSplitComponent[0];
          const standardSplitComponentType = standardSplitComponent[1];
          const standardSplitComponentParams = standardSplitComponent[2];
          if (standardSplitComponentResult) {
            return [true, standardSplitComponentType, "Standard", standardSplitComponentParams, newInput];
          }
          const inverse = calculateInverse(newInput);
          const inverseSplitComponent = isSplitComponent(inverse);
          const inverseSplitComponentResult = inverseSplitComponent[0];
          const inverseSplitComponentType = inverseSplitComponent[1];
          const inverseSplitComponentParams = inverseSplitComponent[2];
          if (inverseSplitComponentResult) {
            return [true, inverseSplitComponentType, "Inverse", inverseSplitComponentParams, newInput];
          }
          const complement = calculateComplement(newInput);
          const isComplementSplitComponent = isSplitComponent(complement);
          const isComplementSplitComponentResult = isComplementSplitComponent[0];
          const isComplementSplitComponentType = isComplementSplitComponent[1];
          const isComplementSplitComponentParams = isComplementSplitComponent[2];
          if (isComplementSplitComponentResult) {
            return [true, isComplementSplitComponentType, "Complement", isComplementSplitComponentParams, newInput];
          }
          const complementOfInverse = calculateComplement(complement);
          const isComplementOfInverseSplitComponent = isSplitComponent(complementOfInverse);
          const isComplementOfInverseSplitComponentResult = isComplementOfInverseSplitComponent[0];
          const isComplementOfInverseSplitComponentType = isComplementOfInverseSplitComponent[1];
          const isComplementOfInverseSplitComponentParams = isComplementOfInverseSplitComponent[2];
          if (isComplementOfInverseSplitComponentResult) {
            return [true, isComplementOfInverseSplitComponentType, "Complement of Inverse", isComplementOfInverseSplitComponentParams, newInput];
          }
          return [false, "None", "None", "None"];
        } else {
          const nonSplitComponent = isNonSplitComponent(input);
          const nonSplitComponentResult = nonSplitComponent[0];
          const nonSplitComponentType = nonSplitComponent[1];
          const nonSplitComponentParams = nonSplitComponent[2];
          if (nonSplitComponentResult) {
            return [true, nonSplitComponentType, "Standard", nonSplitComponentParams, input];
          }
          const complement = calculateComplement(input);
          const inverseNonSplitComponent = isNonSplitComponent(complement);
          const inverseNonSplitComponentResult = inverseNonSplitComponent[0];
          const inverseNonSplitComponentType = inverseNonSplitComponent[1];
          const inverseNonSplitComponentParams = inverseNonSplitComponent[2];
          if (inverseNonSplitComponentResult) {
            return [true, inverseNonSplitComponentType, "Complement", inverseNonSplitComponentParams, input];
          }
          return [false, "None", "None", "None"];
        }
      }

      function isSplitComponent(input) {
        const isSVGComponent = isSVG(input);
        const isSVGResult = isSVGComponent[0];
        if (isSVGResult) {
          return [true, "SVG", isSVGComponent[1]];
        }
        const isSpqComponent = isSpq(input);
        const isSpqResult = isSpqComponent[0];
        if (isSpqResult) {
          return [true, "Spq", isSpqComponent[1]];
        }
        const isS2Component = isS2(input);
        const isS2Result = isS2Component[0];
        if (isS2Result) {
          return [true, "S2", isS2Component[1]];
        }
        const isS3Component = isS3(input);
        const isS3Result = isS3Component[0];
        if (isS3Result) {
          return [true, "S3", isS3Component[1]];
        }
        const isS4Component = isS4(input);
        const isS4Result = isS4Component[0];
        if (isS4Result) {
          return [true, "S4", isS4Component[1]];
        }
        return [false, "None", "None"];
      }

      function isNonSplitComponent(input) {
        const isC5Component = isC5(input);
        const isC5Result = isC5Component[0];
        if (isC5Result) {
          return [true, "C5", isC5Component[1]];
        }
        const ismK2Component = ismK2(input);
        const ismK2Result = ismK2Component[0];
        if (ismK2Result) {
          return [true, "mK2", ismK2Component[1]];
        }
        const isU2Component = isU2(input);
        const isU2Result = isU2Component[0];
        if (isU2Result) {
          return [true, "U2", isU2Component[1]];
        }
        const isU3Component = isU3(input);
        const isU3Result = isU3Component[0];
        if (isU3Result) {
          return [true, "U3", isU3Component[1]];
        }
        return [false, "None", "None"];
      }

      function isC5(input) {
        const keys = Object.keys(input);
        const values = Object.values(input);
        if (keys.length !== 1 || Number(keys[0]) !== 2 || values[0] !== 5) {
          return [false, "None"];
        }
        return [true, "None"];
      }

      function ismK2(input) {
        const keys = Object.keys(input);
        const values = Object.values(input);
        if (keys.length > 1) {
          return [false, "None"];
        }
        const d1 = Number(keys[0]);
        const r1 = values[0];
        if (d1 !== 1 || r1 % 2 !== 0) {
          return [false, "None"];
        }
        const m = r1 / 2;
        if (m < 2) {
          return [false, "None"];
        }
        return [true, {m: m}];
      }

      function isU2(input) {
        const ds = Object.keys(input).sort((a, b) => b - a);
        if (ds.length !== 2) {
          return [false, "None"];
        }
        const orderedDs = ds.sort((a, b) => b - a);
        const d1 = Number(orderedDs[0]);
        const r1 = input[d1];
        const d2 = Number(orderedDs[1]);
        const r2 = input[d2];
        if (r1 !== 1 || r2 <= 1 || d2 !== 1) {
          return [false, "None"];
        }
        if ((r2 - d1) % 2 !== 0) {
          return [false, "None"];
        }
        const m = (r2 - d1) / 2;
        if (m < 1) {
          return [false, "None"];
        }
        const l = d1;
        if (l < 1) {
          return [false, "None"];
        }
        return [true, {l: l, m: m}];
      }

      function isU3(input) {
        const ds = Object.keys(input);
        if (ds.length !== 2) {
          return [false, "None"];
        }
        const orderedDs = ds.sort((a, b) => b - a);
        const d1 = Number(orderedDs[0]);
        const r1 = input[d1];
        const d2 = Number(orderedDs[1]);
        const r2 = input[d2];
        if (r1 !== 1 || r2 <= 1 || d2 !== 2) {
          return [false, "None"];
        }
        if ((d1 - 2) % 2 !== 0) {
          return [false, "None"];
        }
        const m = (d1 - 2) / 2;
        if (m < 1) {
          return [false, "None"];
        }
        return [true, {m: m}];
      }

      function isSVG(input) {
        const a = input.A;
        const b = input.B;
        const dA = Object.keys(a);
        const rA = Object.values(a);
        const dB = Object.keys(b);
        const rB = Object.values(b);
        if (dA.length > 1 || dB.length > 1) {
          return [false, "None"];
        }
        if (dA.length !== 1 && dB.length !== 1) {
          return [false, "None"]  ;
        }
        if (dA.length === 0 && dB.length === 0) {
          return [false, "None"];
        }
        if (dA.length === 1 && dB.length === 0) {
          const d1 = Number(dA[0]);
          const r1 = rA[0];
          if (d1 == 0 || r1 == 1) {
            return [true, {partition: "A", compacted: false}];
          }
          if (r1 > d1 && r1 - d1 == 1) {
            return [true, {partition: "A", compacted: true}];
          }
        }
        if (dA.length === 0 && dB.length === 1) {
          const d2 = Number(dB[0]);
          const r2 = rB[0];
          if (d2 == 0 || r2 == 1) {
            return [true, {partition: "B", compacted: false}];
          }
          if (d2 == 2 && r2 > 1) {
            return [true, {partition: "B", compacted: true}];
          }
        }
        return [false, "None"];
      }

      function isSpq(input) {
        const a = input.A;
        const b = input.B;
        const dA = Object.keys(a);
        const rA = Object.values(a);
        const dB = Object.keys(b);
        const rB = Object.values(b);
        if (dA.length !== 1 || dB.length !== 1) {
          return [false, "None"];
        }
        const d1 = Number(dA[0]);
        const r1 = rA[0];
        const d2 = Number(dB[0]);
        const r2 = rB[0];
        if (r2 % r1 !== 0 || d2 !== 1) {
          return [false, "None"];
        }
        const p = r2 / r1;
        const q = r1;
        if (p < 1 || q < 2) {
          return [false, "None"];
        }
        return [true, {p: p, q: q}];
      }

      function isS2(input) {
        const a = input.A;
        const b = input.B;
        const dA = Object.keys(a);
        const rA = Object.values(a);
        const dB = Object.keys(b);
        const rB = Object.values(b);
        if (dA.length < 2 || dB.length !== 1 || Number(dB[0]) !== 1) {
          return [false, "None"];
        }
        let p = [];
        let q = [];
        const n = rA.reduce((a, b) => a + b, 0);
        const orderedDAs = dA.sort((a, b) => b - a);
        for (let i = 1; i <= orderedDAs.length; i++) {
          const d = Number(orderedDAs[i - 1]);
          const r = a[d];
          p[i] = d - n + 1;
          q[i] = r;
          if (p[i - 1] <= p[i]) {
            return [false, "None"];
          }
        }
        return [true, {p: p, q: q}];
      }

      function isS3(input) {
        const a = input.A;
        const b = input.B;
        const dA = Object.keys(a);
        const rA = Object.values(a);
        const dB = Object.keys(b);
        const rB = Object.values(b);
        if (dA.length !== 1 || dB.length !== 2) {
          return [false, "None"];
        }
        const d1 = Number(dA[0]);
        const r1 = rA[0];
        const orderedDBs = dB.sort((a, b) => b - a);
        const d2 = Number(orderedDBs[0]);
        const r2 = b[d2];
        const d3 = Number(orderedDBs[1]);
        const r3 = b[d3];
        if (r2 !== 1 || d3 !== 1) {
          return [false, "None"];
        }
        const p = d1 - r1;
        const q1 = d2;
        const q2 = r1 - d2;
        if (p < 1 || q1 < 2 || q2 < 1) {
          return [false, "None"];
        }
        return [true, {p: p, q1: q1, q2: q2}];
      }

      function isS4(input) {
        const a = input.A;
        const b = input.B;
        const dA = Object.keys(a);
        const rA = Object.values(a);
        const dB = Object.keys(b);
        const rB = Object.values(b);
        if (dA.length !== 2 || dB.length !== 1) {
          return [false, "None"];
        }
        const orderedDAs = dA.sort((a, b) => b - a);
        const d1 = Number(orderedDAs[0]);
        const r1 = a[d1];
        const d2 = Number(orderedDAs[1]);
        const r2 = a[d2];
        const d3 = Number(dB[0]);
        const r3 = b[d3];
        if (r1 !== 1 || d3 !== 2) {
          return [false, "None"];
        }
        const q = r2 - 2;
        const p = d2 - 3 - q;
        if (p < 1 || q < 1) {
          return [false, "None"];
        }
        if (d1 !== 2 * (p + q + 1) + q || r3 !== (q * p) + (2 * p) + q + 1) {
          return [false, "None"];
        }
        return [true, {p: p, q: q}];
      }

      function isSplitGraph(input) {
        if (input.A === undefined || input.B === undefined) {
          let i = 1;
          const orderedKeys = Object.keys(input).sort((a, b) => b - a);
          let orderedDegArray = [undefined];
          for (let i = 0; i < orderedKeys.length; i++) {
            const value = Number(input[orderedKeys[i]]);
            for (let j = 0; j < value; j++) {
              orderedDegArray.push(Number(orderedKeys[i]));
            }
          }
          const n = orderedDegArray.length - 1;
          while (i <= n - 1 && orderedDegArray[i + 1] >= i) {
            i++;
          }
          const h = i;
          let leftSum = 0;
          let rightSum = 0;
          for (let i = 1; i <= h; i++) {
            leftSum += Number(orderedDegArray[i]);
          }
          for (let i = h + 1; i <= n; i++) {
            rightSum += Number(orderedDegArray[i]);
          }
          if (leftSum == ((h - 1) * h) + rightSum) {
            let newDegSequence = {};
            let a = {}
            for (let i = 1; i <= h; i++) {
              if (a[orderedDegArray[i]] === undefined) {
                a[orderedDegArray[i]] = 1;
              } else {
                a[orderedDegArray[i]]++;
              }
            }
            let b = {};
            for (let i = h + 1; i <= n; i++) {
              if (b[orderedDegArray[i]] === undefined) {
                b[orderedDegArray[i]] = 1;
              } else {
                b[orderedDegArray[i]]++;
              }
            }
            return [true, {A: a, B: b}];
          }
          return [false, input];
        } else {
          return [true, input];
        }
      }

      function factorial(n) {
        if (n === 0) return 1;
        let result = 1;
        for (let i = 1; i <= n; i++) {
          result *= i;
        }
        return result;
      }

      // Initialize the HTML when the page loads
      document.addEventListener('DOMContentLoaded', initializeHTML);
    </script>
  </body>
</html>
